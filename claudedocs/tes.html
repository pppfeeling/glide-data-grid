<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Canvas Grid - ìµœì¢… IME í•´ê²° (DataLudi ë°©ì‹)</title>
    <style>
        body { margin: 0; padding: 20px; font-family: sans-serif; }
        #container { position: relative; display: inline-block; border: 2px solid #333; }
        #gridCanvas { display: block; cursor: cell; }
        /* ğŸ”‘ í•µì‹¬ 1: í”„ë¡ì‹œ ì…ë ¥ í•„ë“œ - í™”ë©´ ë°–ìœ¼ë¡œ ìˆ¨ê¹€ */
        #proxyInput {
            position: absolute;
            top: -1000px;
            left: -1000px;
            width: 10px;
            height: 10px;
            opacity: 0;
            pointer-events: none; /* ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë¬´ì‹œ */
        }
        #cellEditor {
            position: absolute;
            border: 2px solid #007acc;
            padding: 0 4px;
            margin: 0;
            font-size: 14px;
            font-family: Arial, sans-serif;
            background: white;
            z-index: 1000;
            outline: none;
            box-sizing: border-box;
        }

        /* ğŸ”‘ í¸ì§‘ ëª¨ë“œê°€ ì•„ë‹ ë•ŒëŠ” ìˆ¨ê¹€ (í”„ë¡ì‹œë¡œ ì‚¬ìš©) */
        #cellEditor:not(.editing) {
            top: -1000px;
            left: -1000px;
            width: 10px;
            height: 10px;
            opacity: 0;
            pointer-events: none;
        }
        .info { margin-top: 20px; padding: 10px; background: #f0f0f0; border-radius: 4px; }
        .debug {
            margin-top: 10px; padding: 10px; background: #fff3cd;
            border: 1px solid #ddd; border-radius: 4px; font-family: monospace;
            font-size: 12px; height: 200px;
            overflow-y: scroll; white-space: pre-wrap;
        }
    </style>
</head>
<body>
    <h2>Canvas Grid - í†µí•©ëœ CellEditor ë°©ì‹</h2>
    <p>`cellEditor` í•˜ë‚˜ë¡œ ëª¨ë“  ê±¸ ì²˜ë¦¬: ìˆ¨ê¹€ ìƒíƒœì—ì„œ í”„ë¡ì‹œ ì—­í• , í¸ì§‘ ëª¨ë“œì—ì„œëŠ” í•´ë‹¹ ì…€ ìœ„ì¹˜ì— í‘œì‹œë©ë‹ˆë‹¤.</p>

    <div id="container">
        <canvas id="gridCanvas" width="600" height="400"></canvas>
        <!-- ğŸ”‘ í•µì‹¬ 1: cellEditorë¥¼ ìˆ¨ê¹€ ìƒíƒœë¡œ ë‘ê³  í”„ë¡ì‹œë¡œë„ ì‚¬ìš© -->
        <input type="text" id="cellEditor" spellcheck="false" autocomplete="off" autocapitalize="off" />
    </div>

    <div class="info">
        <strong>í†µí•©ëœ CellEditor ë™ì‘ ë°©ì‹:</strong><br>
        1. Canvas í´ë¦­ ì‹œ, <strong>`#cellEditor`</strong>ì— í¬ì»¤ìŠ¤ë¥¼ ì¤ë‹ˆë‹¤. (ìˆ¨ê¹€ ìƒíƒœ)<br>
        2. ì‚¬ìš©ìê°€ 'ê°€'ë¥¼ ì…ë ¥í•˜ë©´ í•œê¸€ ì¡°í•©ì´ ìˆ¨ê²¨ì§„ <strong>`#cellEditor`</strong>ì—ì„œ ì§„í–‰ë©ë‹ˆë‹¤.<br>
        3. ì¡°í•©ì´ ì™„ë£Œë˜ë©´ <strong>`input`</strong> ì´ë²¤íŠ¸ê°€ ë°œìƒí•˜ì—¬ í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜ë©ë‹ˆë‹¤.<br>
        4. <strong>`#cellEditor`</strong>ê°€ í•´ë‹¹ ì…€ ìœ„ì¹˜ì— ë‚˜íƒ€ë‚˜ì„œ ì…ë ¥ëœ ë‚´ìš©ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.<br>
        5. í¸ì§‘ ì™„ë£Œ ì‹œ ë‚´ìš©ì´ Canvasì— ì €ì¥ë˜ê³  ë‹¤ì‹œ ìˆ¨ê¹€ ìƒíƒœë¡œ ì „í™˜ë©ë‹ˆë‹¤.
    </div>

    <div style="display: flex; align-items: center; gap: 10px; margin-top: 10px;">
        <strong>ë””ë²„ê·¸ ë¡œê·¸:</strong>
        <button onclick="clearLog()" style="padding: 4px 8px; font-size: 11px;">ë¡œê·¸ í´ë¦¬ì–´</button>
    </div>
    <div class="debug" id="debugLog"></div>

    <script>
        class CanvasGrid {
            constructor() {
                this.canvas = document.getElementById('gridCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.editor = document.getElementById('cellEditor');
                this.debugLog = document.getElementById('debugLog');

                this.cellWidth = 120;
                this.cellHeight = 30;
                this.rows = 10;
                this.cols = 5;

                this.selectedRow = 0;
                this.selectedCol = 0;

                this.data = Array(this.rows).fill().map(() => Array(this.cols).fill(''));
                this.isEditing = false;
                this.isComposing = false;
                this.debugMessages = [];

                this.init();
            }

            init() {
                this.drawGrid();
                this.bindEvents();
                this.focusEditor();
                this.log('Canvas ì´ˆê¸°í™” ì™„ë£Œ. ì…€ì„ í´ë¦­í•˜ê±°ë‚˜ ë°©í–¥í‚¤ë¡œ ì´ë™ í›„ ë¬¸ìë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
            }
            
            log(message) {
                this.debugMessages.unshift(`${new Date().toLocaleTimeString()}: ${message}`);
                if (this.debugMessages.length > 50) this.debugMessages.pop();
                this.debugLog.innerHTML = this.debugMessages.join('<br>');
                this.debugLog.scrollTop = 0;
            }

            bindEvents() {
                // ğŸ”‘ í•µì‹¬ 2: Canvas í´ë¦­ ì‹œ CellEditorì— í¬ì»¤ìŠ¤
                this.canvas.addEventListener('click', this.handleCanvasClick.bind(this));
                this.canvas.addEventListener('dblclick', this.handleCanvasDblClick.bind(this));

                // ğŸ”‘ í•µì‹¬ 3: CellEditorì—ì„œ ëª¨ë“  ì´ë²¤íŠ¸ ì²˜ë¦¬
                this.editor.addEventListener('keydown', this.handleEditorKeydown.bind(this));
                this.editor.addEventListener('input', this.handleEditorInput.bind(this));
                this.editor.addEventListener('blur', this.handleEditorBlur.bind(this));
                
            }

            focusEditor() {
                this.editor.focus();
                this.log('CellEditorì— í¬ì»¤ìŠ¤ ì„¤ì •');
            }

            handleCanvasClick(e) {
                if (this.isEditing) this.finishEdit();

                const rect = this.canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                const col = Math.floor(x / this.cellWidth);
                const row = Math.floor(y / this.cellHeight);

                if (row >= 0 && row < this.rows && col >= 0 && col < this.cols) {
                    this.selectCell(row, col);
                }
                this.focusEditor();
            }

            handleCanvasDblClick(e) {
                if (!this.isEditing) {
                    this.log('ë”ë¸”í´ë¦­ìœ¼ë¡œ í¸ì§‘ ì‹œì‘');
                    this.startEdit(true); // ë”ë¸”í´ë¦­ ì‹œ ê¸°ì¡´ ë‚´ìš© ìœ ì§€
                }
            }
            
            // ğŸ”‘ í•µì‹¬ 4: CellEditorì˜ input í•¸ë“¤ëŸ¬
            handleEditorInput(e) {
                const inputText = this.editor.value;
                this.log(`Editor input: "${inputText}" (í¸ì§‘ì¤‘: ${this.isEditing}, ì¡°í•©ì¤‘: ${this.isComposing})`);

                // í¸ì§‘ ëª¨ë“œê°€ ì•„ë‹ˆê³  ì…ë ¥ì´ ìˆìœ¼ë©´ í¸ì§‘ ì‹œì‘
                if (!this.isEditing && inputText && !this.isComposing) {
                    this.log(`í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜: "${inputText}"`);
                    this.startEdit(false, inputText);
                }
            }

            handleEditorKeydown(e) {
                this.log(`Editor keydown: key="${e.key}" (í¸ì§‘ì¤‘: ${this.isEditing})`);

                if (this.isComposing) return;

                if (this.isEditing) {
                    // í¸ì§‘ ëª¨ë“œì¼ ë•Œ
                    switch(e.key) {
                        case 'Enter':
                            this.finishEdit();
                            this.moveSelection(1, 0);
                            e.preventDefault();
                            break;
                        case 'Tab':
                            this.finishEdit();
                            this.moveSelection(0, e.shiftKey ? -1 : 1);
                            e.preventDefault();
                            break;
                        case 'Escape':
                            this.cancelEdit();
                            e.preventDefault();
                            break;
                    }
                } else {
                    // íƒìƒ‰ ëª¨ë“œì¼ ë•Œ
                    if (this.isNavigationKey(e)) {
                        e.preventDefault();
                        this.handleNavigationKey(e);
                    }
                }
            }

            handleEditorBlur() {
                this.log('Editor blur ì´ë²¤íŠ¸ ë°œìƒ');
                // IME ì¡°í•© ì¤‘ì— í¬ì»¤ìŠ¤ê°€ ë– ë‚˜ëŠ” ê²ƒì„ ë°©ì§€
                setTimeout(() => {
                    if (this.isEditing && !this.isComposing) {
                        this.log('í¸ì§‘ ì¢…ë£Œ (blurë¡œ ì¸í•œ)');
                        this.finishEdit();
                    }
                }, 100);
            }
            
            isNavigationKey(e) {
                const navKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Home', 'End', 'PageUp', 'PageDown', 'Delete', 'Backspace', 'F2'];
                return navKeys.includes(e.key);
            }

            // ğŸ”‘ í•µì‹¬ 5: startEdit - cellEditorë¥¼ í¸ì§‘ ëª¨ë“œë¡œ ì „í™˜
            startEdit(keepContent = false, initialText = '') {
                if (this.isEditing) return;

                this.isEditing = true;
                this.editor.classList.add('editing'); // í¸ì§‘ ëª¨ë“œ CSS í´ë˜ìŠ¤ ì¶”ê°€
                this.drawGrid();

                const x = this.selectedCol * this.cellWidth;
                const y = this.selectedRow * this.cellHeight;

                // í¸ì§‘ ëª¨ë“œì—ì„œëŠ” ì…€ ìœ„ì¹˜ì— í‘œì‹œ
                this.editor.style.left = x + 'px';
                this.editor.style.top = y + 'px';
                this.editor.style.width = this.cellWidth + 'px';
                this.editor.style.height = this.cellHeight + 'px';

                const value = keepContent ? this.data[this.selectedRow][this.selectedCol] || '' : initialText;
                this.editor.value = value;
                this.log(`í¸ì§‘ ì‹œì‘: (${this.selectedRow}, ${this.selectedCol}) - ì´ˆê¸°ê°’: "${value}"`);

                this.editor.focus();
                this.editor.setSelectionRange(value.length, value.length);
            }


            finishEdit() {
                if (!this.isEditing) return;

                this.log(`í¸ì§‘ ì™„ë£Œ: "${this.editor.value}"`);

                // Canvasì— ê°’ ì €ì¥
                this.data[this.selectedRow][this.selectedCol] = this.editor.value;

                // í¸ì§‘ ëª¨ë“œ í•´ì œ
                this.editor.classList.remove('editing');
                this.editor.value = ''; // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                this.isEditing = false;

                this.focusEditor(); // ë‹¤ì‹œ ìˆ¨ê¹€ ìƒíƒœë¡œ í¬ì»¤ìŠ¤ ìœ ì§€
                this.drawGrid();
            }

            cancelEdit() {
                if (!this.isEditing) return;

                this.log('í¸ì§‘ ì·¨ì†Œ');

                // í¸ì§‘ ëª¨ë“œ í•´ì œ
                this.editor.classList.remove('editing');
                this.editor.value = ''; // ì…ë ¥ í•„ë“œ ì´ˆê¸°í™”
                this.isEditing = false;

                this.focusEditor(); // ë‹¤ì‹œ ìˆ¨ê¹€ ìƒíƒœë¡œ í¬ì»¤ìŠ¤ ìœ ì§€
                this.drawGrid();
            }

            handleNavigationKey(e) {
                let deltaRow = 0, deltaCol = 0;
                
                switch(e.key) {
                    case 'ArrowUp': deltaRow = -1; break;
                    case 'ArrowDown': deltaRow = 1; break;
                    case 'ArrowLeft': deltaCol = -1; break;
                    case 'ArrowRight': deltaCol = 1; break;
                    case 'F2': this.startEdit(true); return;
                    case 'Delete':
                    case 'Backspace':
                        this.data[this.selectedRow][this.selectedCol] = '';
                        this.drawGrid();
                        return;
                }
                
                this.moveSelection(deltaRow, deltaCol);
            }
            
            selectCell(row, col) {
                this.selectedRow = row;
                this.selectedCol = col;
                this.drawGrid();
                this.log(`ì…€ ì„ íƒ: (${row}, ${col})`);
            }
            
            moveSelection(deltaRow, deltaCol) {
                const newRow = Math.max(0, Math.min(this.rows - 1, this.selectedRow + deltaRow));
                const newCol = Math.max(0, Math.min(this.cols - 1, this.selectedCol + deltaCol));
                this.selectCell(newRow, newCol);
            }
            
            drawGrid() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                for (let row = 0; row < this.rows; row++) {
                    for (let col = 0; col < this.cols; col++) {
                        const x = col * this.cellWidth;
                        const y = row * this.cellHeight;
                        
                        this.ctx.strokeStyle = '#ccc';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(x, y, this.cellWidth, this.cellHeight);
                        
                        const text = this.data[row][col];
                        if (text) {
                            this.ctx.fillStyle = '#333';
                            this.ctx.font = '14px Arial';
                            this.ctx.textAlign = 'left';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText(text, x + 5, y + this.cellHeight / 2);
                        }
                    }
                }
                
                if (!this.isEditing) {
                    const x = this.selectedCol * this.cellWidth;
                    const y = this.selectedRow * this.cellHeight;
                    this.ctx.strokeStyle = '#007acc';
                    this.ctx.lineWidth = 2;
                    this.ctx.strokeRect(x, y, this.cellWidth, this.cellHeight);
                }
            }
        }
        
        function clearLog() {
            const gridInstance = window.gridInstance;
            if (gridInstance) {
                gridInstance.debugMessages = [];
                gridInstance.log('ë¡œê·¸ê°€ ìˆ˜ë™ìœ¼ë¡œ í´ë¦¬ì–´ë˜ì—ˆìŠµë‹ˆë‹¤.');
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            window.gridInstance = new CanvasGrid();
        });
    </script>
</body>
</html>